name: CI with Static TC Build

# 定義觸發條件
on: 
  push:
    paths-ignore:
      - '**.md'
  pull_request:
  workflow_dispatch:
    inputs:
      debug_enabled:
        description: 'Run the build with tmate debugging enabled'      
        required: false
        default: 'no'
  release:
    types: [published]

jobs:
  build:
    name: build
    runs-on: ubuntu-latest
    if: ${{ !(github.event_name == 'push' && startsWith(github.ref, 'refs/tags/')) }}
    env:
      build_variant: ${{ matrix.build_variant }}
      targets: ${{ matrix.targets }}
      images_dir: /opt/images
    strategy:
      matrix:
        include:
          - build_variant: "mt7621"
            targets: "K2P"
            
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      
      - name: Prepare environment (Install dependencies)
        run: |
          sudo apt update
          sudo apt install -y libtool-bin gperf python3-docutils autopoint gettext bison flex wget xz-utils
          # 修正點：補齊 32-bit C/C++ 運行時依賴，解決 Error 127
          sudo apt install -y libc6-i386 lib32z1 lib32stdc++6 
          
      # -----------------------------------------------------------
      # 步驟 1: 下載並設定 MIPS 交叉編譯器 (修正 STAGING_DIR 偵測)
      # -----------------------------------------------------------
      - name: ⬇️ 下載並設定 MIPS 交叉編譯器 (OpenWrt SDK)
        id: toolchain_setup
        run: |
          TOOLCHAIN_VERSION="23.05.2"  
          TOOLCHAIN_FILENAME="openwrt-sdk-${TOOLCHAIN_VERSION}-ramips-mt7621_gcc-12.3.0_musl.Linux-x86_64.tar.xz"
          
          # SDK 下載及解壓重試邏輯 (已證明有效)
          MAX_RETRIES=2
          RETRY_COUNT=0
          SDK_DOWNLOAD_URL="https://downloads.openwrt.org/releases/${TOOLCHAIN_VERSION}/targets/ramips/mt7621/${TOOLCHAIN_FILENAME}"
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              echo "嘗試下載 OpenWrt SDK (第 $((RETRY_COUNT + 1)) 次)..."
              wget "$SDK_DOWNLOAD_URL" -O sdk.tar.xz
              
              echo "解壓工具鏈..."
              mkdir -p sdk
              if tar -Jxf sdk.tar.xz -C sdk --strip-components=1; then
                  echo "SDK 解壓成功。"
                  break
              else
                  RETRY_COUNT=$((RETRY_COUNT + 1))
                  if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
                      echo "::error::錯誤：SDK 下載及解壓在 ${MAX_RETRIES} 次嘗試後仍失敗。"
                      exit 1
                  fi
                  echo "::warning::警告：解壓失敗。清理並重試..."
                  rm -rf sdk sdk.tar.xz 
              fi
          done

          # 尋找編譯器絕對路徑
          TOOLCHAIN_COMPILER_PATH=$(find sdk/staging_dir -type f -name "*gcc" | head -n 1)
          
          if [ -z "$TOOLCHAIN_COMPILER_PATH" ]; then
            echo "::error::錯誤：找不到編譯器。"
            exit 1
          fi

          TOOLCHAIN_BIN=$(dirname "$TOOLCHAIN_COMPILER_PATH")
          TOOLCHAIN_PREFIX=$(basename "$TOOLCHAIN_COMPILER_PATH" | sed 's/gcc$//')
          
          # ！！！ 修正點：簡化且更穩健地尋找 STAGING_DIR ！！！
          # 直接在 sdk/staging_dir 內尋找 target-xxx 目錄 (這是最穩健的方法)
          STAGING_DIR=$(find sdk/staging_dir -maxdepth 1 -type d -name "target-*" | head -n 1)
          
          if [ -z "$STAGING_DIR" ]; then
            echo "::error::錯誤：找不到 Target Staging Directory (在 sdk/staging_dir 內)。"
            exit 1
          fi
          
          echo "偵測到的工具鏈前綴: ${TOOLCHAIN_PREFIX}"
          echo "偵測到的 Staging Dir: ${STAGING_DIR}"

          # 匯出所有環境變數
          echo "CROSS_COMPILE=$TOOLCHAIN_PREFIX" >> $GITHUB_ENV
          echo "CC_FULL_PATH=$TOOLCHAIN_COMPILER_PATH" >> $GITHUB_ENV
          echo "STAGING_DIR=$STAGING_DIR" >> $GITHUB_ENV
          echo "IPROUTE2_VERSION_LATEST=6.17.0" >> $GITHUB_ENV  
          echo "IPROUTE2_VERSION_FALLBACK=6.8.0" >> $GITHUB_ENV
          echo "TC_STATIC_PATH=${{ github.workspace }}/tc_static_bin" >> $GITHUB_ENV
          
        shell: bash

      # -----------------------------------------------------------
      # 步驟 1.5: 靜態交叉編譯 libmnl (解決 tc 依賴)
      # -----------------------------------------------------------
      - name: ⚙️ Pre-compile and Install libmnl
        run: |
          LIBMNL_VERSION="1.2.0"
          LIBMNL_URL="https://netfilter.org/projects/libmnl/files/libmnl-${LIBMNL_VERSION}.tar.bz2"
          HOST_TRIPLE=$(echo "${{ env.CROSS_COMPILE }}" | sed 's/-$//')

          echo "下載 libmnl v${LIBMNL_VERSION}..."
          wget "${LIBMNL_URL}"
          tar -xf libmnl-${LIBMNL_VERSION}.tar.bz2
          cd libmnl-${LIBMNL_VERSION}
          
          # 執行 configure，設定交叉編譯、禁用共享函式庫、啟用靜態函式庫
          ./configure --host=$HOST_TRIPLE \
                      --prefix=/usr \
                      --disable-shared \
                      --enable-static \
                      CC="${{ env.CC_FULL_PATH }}" \
                      CFLAGS="-Os -pipe" \
                      LDFLAGS=""
          
          make
          # 將靜態函式庫和標頭檔安裝到 SDK 的目標目錄
          make install DESTDIR="${{ env.STAGING_DIR }}"
          
          echo "libmnl 靜態編譯完成並安裝到 ${{ env.STAGING_DIR }}/usr/lib"
          cd ..
        shell: bash
        
      # -----------------------------------------------------------
      # 步驟 2: 靜態編譯 TC (使用 CC 絕對路徑及 libmnl 連結旗標)
      # -----------------------------------------------------------
      - name: Download and Statically Compile TC
        run: |
          LATEST_VERSION="${{ env.IPROUTE2_VERSION_LATEST }}"
          FALLBACK_VERSION="${{ env.IPROUTE2_VERSION_FALLBACK }}"
          VERSION_TO_USE=""
          ARCHIVE_SUFFIX=""
          BASE_URL="https://www.kernel.org/pub/linux/utils/net/iproute2/"
          AR_FULL_PATH=$(echo "${{ env.CC_FULL_PATH }}" | sed 's/gcc$/ar/')

          # 函數：嘗試下載並設定版本 (已修正)
          try_download() {
              local version=$1
              if wget "${BASE_URL}iproute2-${version}.tar.xz"; then
                  VERSION_TO_USE="${version}"; ARCHIVE_SUFFIX=".tar.xz"; echo "已找到版本 ${version} (${ARCHIVE_SUFFIX}) - 優先使用。"; return 0
              fi
              if wget "${BASE_URL}iproute2-${version}.tar.gz"; then
                  VERSION_TO_USE="${version}"; ARCHIVE_SUFFIX=".tar.gz"; echo "已找到版本 ${version} (${ARCHIVE_SUFFIX})。" ; return 0
              fi
              return 1
          }

          # 執行下載
          echo "嘗試下載最新版本 iproute2-${LATEST_VERSION}..."
          if ! try_download "${LATEST_VERSION}"; then
              echo "::warning::警告：最新版本 ${LATEST_VERSION} 無法下載。嘗試回退到 ${FALLBACK_VERSION} 版本。"
              if ! try_download "${FALLBACK_VERSION}"; then
                  echo "::error::錯誤：下載失敗。" ; exit 1
              fi
          fi

          # 解壓
          tar -xf iproute2-${VERSION_TO_USE}${ARCHIVE_SUFFIX}
          cd iproute2-${VERSION_TO_USE}

          # 靜態交叉編譯 tc：
          # 確保連結到 libmnl
          make CC="${{ env.CC_FULL_PATH }}" \
               LDFLAGS="-static -L${{ env.STAGING_DIR }}/usr/lib -lmnl" \
               CFLAGS="-I${{ env.STAGING_DIR }}/usr/include" \
               AR="${AR_FULL_PATH}" \
               SUBDIRS=tc 
          
          mkdir -p ${{ env.TC_STATIC_PATH }}
          if [ ! -f "tc/tc" ]; then
            echo "::error::錯誤：tc/tc 執行檔未成功生成，靜態編譯失敗。"
            exit 1
          fi
          
          cp tc/tc ${{ env.TC_STATIC_PATH }}/tc_static_mipsel
          
          echo "--- 靜態連結驗證結果 ---"
          file ${{ env.TC_STATIC_PATH }}/tc_static_mipsel
          
          echo "IPROUTE2_VERSION=${VERSION_TO_USE}" >> $GITHUB_ENV

        shell: bash

      # -----------------------------------------------------------
      # 步驟 3: 上傳靜態 TC Binary 作為 Artifact
      # -----------------------------------------------------------
      - name: Upload Static TC Binary as Artifact
        uses: actions/upload-artifact@v4
        with:
          name: tc_static_mipsel_${{ env.IPROUTE2_VERSION }} 
          path: ${{ env.TC_STATIC_PATH }}/tc_static_mipsel
          retention-days: 90
          
      # -----------------------------------------------------------
      # 後續韌體編譯流程
      # -----------------------------------------------------------
      - name: Setup tmate session
        uses: mxschmitt/action-tmate@v3
        if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.debug_enabled == 'yes' }}
        with:
          limit-access-to-actor: true
          
      - name: Start build
        run: |
          cd trunk
          mkdir -p ${images_dir}
          for m in $targets; do 
            fakeroot ./build_firmware_ci $m
            if [ $? -eq 0 ]; then 
              cp -f images/*.trx ${images_dir}/$m.trx
            else 
              echo "::error::韌體編譯失敗: $m"
              exit 1
            fi
            ./clear_tree_simple >/dev/null 2>&1
          done
          
      - name: Create archive
        if: ${{ github.event_name != 'release' && success() }}
        run: |
          ls -lh ${images_dir}
          GIT_VERSION=`git rev-parse --short=7 HEAD 2>/dev/null` && [ -n "$GIT_VERSION" ] && \
          image_name=images_${build_variant}_${GIT_VERSION} || image_name=images_${build_variant}
          cd ${images_dir}; md5sum *.trx |tee md5sum.txt; 7z a -mx=9 ${image_name}.7z ./*
          echo "image_name=${image_name}" >> $GITHUB_ENV
          
      - name: Upload images to Artifact
        if: ${{ github.event_name != 'release' && success() }}
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.image_name }}
          path: ${{ env.images_dir }}/*.7z
          
      - name: Upload images to Releases
        if: ${{ github.event_name != 'release' && success() }}
        uses: svenstaro/upload-release-action@2.2.0
        with:
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          file: ${{ env.images_dir }}/*.trx
          tag: ${{ github.ref }}
          overwrite: true
          file_glob: true
