name: CI with Static TC Build

# 定義觸發條件
on: 
  push:
    paths-ignore:
      - '**.md'
  pull_request:
  workflow_dispatch:
    inputs:
      debug_enabled:
        description: 'Run the build with tmate debugging enabled'      
        required: false
        default: 'no'
  release:
    types: [published]

jobs:
  build:
    name: build
    runs-on: ubuntu-latest
    if: ${{ !(github.event_name == 'push' && startsWith(github.ref, 'refs/tags/')) }}
    env:
      build_variant: ${{ matrix.build_variant }}
      targets: ${{ matrix.targets }}
      images_dir: /opt/images
    strategy:
      matrix:
        include:
          - build_variant: "mt7621"
            targets: "K2P"
            
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      
      - name: Prepare environment (Install dependencies)
        run: |
          sudo apt update
          # 安裝編譯所需的依賴，包括處理 .tar.xz 的 xz-utils
          sudo apt install -y libtool-bin gperf python3-docutils autopoint gettext bison flex wget xz-utils
          # 關鍵：安裝 32-bit 函式庫以支援 OpenWrt MIPS 交叉編譯器運行
          sudo apt install -y libc6-i386 lib32z1
          
      # -----------------------------------------------------------
      # 步驟 1: 下載並設定 MIPS 交叉編譯器 (新增 CC 絕對路徑匯出)
      # -----------------------------------------------------------
      - name: ⬇️ 下載並設定 MIPS 交叉編譯器 (OpenWrt SDK)
        id: toolchain_setup
        run: |
          TOOLCHAIN_VERSION="23.05.2"  
          TOOLCHAIN_FILENAME="openwrt-sdk-${TOOLCHAIN_VERSION}-ramips-mt7621_gcc-12.3.0_musl.Linux-x86_64.tar.xz"
          
          echo "正在下載 OpenWrt SDK..."
          wget "https://downloads.openwrt.org/releases/${TOOLCHAIN_VERSION}/targets/ramips/mt7621/${TOOLCHAIN_FILENAME}" -O sdk.tar.xz
          
          echo "解壓工具鏈..."
          mkdir -p sdk
          tar -xf sdk.tar.xz -C sdk --strip-components=1 || { echo "::error::解壓 SDK 失敗。"; exit 1; }

          # 尋找編譯器絕對路徑 (包含 /sdk/staging_dir/...)
          TOOLCHAIN_COMPILER_PATH=$(find sdk/staging_dir -type f -name "*gcc" | head -n 1)
          
          if [ -z "$TOOLCHAIN_COMPILER_PATH" ]; then
            echo "::error::錯誤：在 SDK 內找不到任何以 'gcc' 結尾的編譯器執行檔，無法繼續。"
            exit 1
          fi

          TOOLCHAIN_BIN=$(dirname "$TOOLCHAIN_COMPILER_PATH")
          TOOLCHAIN_PREFIX=$(basename "$TOOLCHAIN_COMPILER_PATH" | sed 's/gcc$//')
          
          echo "偵測到的工具鏈 bin 目錄: ${TOOLCHAIN_BIN}"
          echo "偵測到的工具鏈前綴: ${TOOLCHAIN_PREFIX}"

          # 關鍵修正：將新的 BIN 目錄匯出到當前 Shell 環境 (即時生效)
          export PATH="$TOOLCHAIN_BIN:$PATH"

          # 匯出環境變數
          echo "PATH=$PATH" >> $GITHUB_ENV
          echo "CROSS_COMPILE=$TOOLCHAIN_PREFIX" >> $GITHUB_ENV
          # ！！！ 修正點：匯出編譯器的絕對路徑 ！！！
          echo "CC_FULL_PATH=$TOOLCHAIN_COMPILER_PATH" >> $GITHUB_ENV
          
          # 設定版本號和路徑
          echo "IPROUTE2_VERSION_LATEST=6.17.0" >> $GITHUB_ENV  
          echo "IPROUTE2_VERSION_FALLBACK=6.8.0" >> $GITHUB_ENV
          echo "TC_STATIC_PATH=${{ github.workspace }}/tc_static_bin" >> $GITHUB_ENV
          
        shell: bash
        
      # -----------------------------------------------------------
      # 步驟 2: 靜態編譯 TC (使用 CC 絕對路徑)
      # -----------------------------------------------------------
      - name: Download and Statically Compile TC
        run: |
          LATEST_VERSION="${{ env.IPROUTE2_VERSION_LATEST }}"
          FALLBACK_VERSION="${{ env.IPROUTE2_VERSION_FALLBACK }}"
          VERSION_TO_USE=""
          ARCHIVE_SUFFIX=""
          BASE_URL="https://www.kernel.org/pub/linux/utils/net/iproute2/"

          # 函數：嘗試下載並設定版本 (優先 .tar.xz)
          try_download() {
              local version=$1
              
              # 優先嘗試下載 .tar.xz (體積最小)
              if wget "${BASE_URL}iproute2-${version}.tar.xz"; then
                  VERSION_TO_USE="${version}"
                  ARCHIVE_SUFFIX=".tar.xz"
                  echo "已找到版本 ${version} (${ARCHIVE_SUFFIX}) - 優先使用。"
                  return 0
              fi
              
              # 其次嘗試下載 .tar.gz
              if wget "${BASE_URL}iproute2-${version}.tar.gz"; then
                  VERSION_TO_USE="${version}"
                  ARCHIVE_SUFFIX=".tar.gz"
                  echo "已找到版本 ${version} (${ARCHIVE_SUFFIX})。"
                  return 0
              fi
              
              return 1
          }

          # 嘗試最新版本
          echo "嘗試下載最新版本 iproute2-${LATEST_VERSION}..."
          if ! try_download "${LATEST_VERSION}"; then
              echo "::warning::警告：最新版本 ${LATEST_VERSION} 無法下載。嘗試回退到 ${FALLBACK_VERSION} 版本。"
              
              # 嘗試備用版本
              if ! try_download "${FALLBACK_VERSION}"; then
                  echo "::error::錯誤：回退版本 ${FALLBACK_VERSION} 仍無法下載。下載失敗。"
                  exit 1
              fi
          fi

          # 解壓
          tar -xf iproute2-${VERSION_TO_USE}${ARCHIVE_SUFFIX}
          cd iproute2-${VERSION_TO_USE}

          # 導出 AR 的絕對路徑 (假設它在同一個 bin 目錄，且名稱以 ar 結尾)
          AR_FULL_PATH=$(echo "${{ env.CC_FULL_PATH }}" | sed 's/gcc$/ar/')

          # 靜態交叉編譯 tc：
          # 修正點：CC 和 AR 皆使用絕對路徑，防止 make 子程序找不到執行檔。
          make CC="${{ env.CC_FULL_PATH }}" \
               LDFLAGS="-static" \
               AR="${AR_FULL_PATH}" \
               SUBDIRS=tc 
          
          mkdir -p ${{ env.TC_STATIC_PATH }}
          if [ ! -f "tc/tc" ]; then
            echo "::error::錯誤：tc/tc 執行檔未成功生成，靜態編譯失敗。"
            exit 1
          fi
          
          cp tc/tc ${{ env.TC_STATIC_PATH }}/tc_static_mipsel
          
          echo "--- 靜態連結驗證結果 ---"
          file ${{ env.TC_STATIC_PATH }}/tc_static_mipsel
          
          # 將最終使用的版本號匯出，以便上傳 Artifact 時使用
          echo "IPROUTE2_VERSION=${VERSION_TO_USE}" >> $GITHUB_ENV

        shell: bash

      # -----------------------------------------------------------
      # 步驟 3: 上傳靜態 TC Binary 作為 Artifact
      # -----------------------------------------------------------
      - name: Upload Static TC Binary as Artifact
        uses: actions/upload-artifact@v4
        with:
          name: tc_static_mipsel_${{ env.IPROUTE2_VERSION }} 
          path: ${{ env.TC_STATIC_PATH }}/tc_static_mipsel
          retention-days: 90
          
      # -----------------------------------------------------------
      # 後續韌體編譯流程
      # -----------------------------------------------------------
      - name: Setup tmate session
        uses: mxschmitt/action-tmate@v3
        if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.debug_enabled == 'yes' }}
        with:
          limit-access-to-actor: true
          
      - name: Start build
        run: |
          cd trunk
          mkdir -p ${images_dir}
          for m in $targets; do 
            fakeroot ./build_firmware_ci $m
            if [ $? -eq 0 ]; then 
              cp -f images/*.trx ${images_dir}/$m.trx
            else 
              echo "::error::韌體編譯失敗: $m"
              exit 1
            fi
            ./clear_tree_simple >/dev/null 2>&1
          done
          
      - name: Create archive
        if: ${{ github.event_name != 'release' && success() }}
        run: |
          ls -lh ${images_dir}
          GIT_VERSION=`git rev-parse --short=7 HEAD 2>/dev/null` && [ -n "$GIT_VERSION" ] && \
          image_name=images_${build_variant}_${GIT_VERSION} || image_name=images_${build_variant}
          cd ${images_dir}; md5sum *.trx |tee md5sum.txt; 7z a -mx=9 ${image_name}.7z ./*
          echo "image_name=${image_name}" >> $GITHUB_ENV
          
      - name: Upload images to Artifact
        if: ${{ github.event_name != 'release' && success() }}
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.image_name }}
          path: ${{ env.images_dir }}/*.7z
          
      - name: Upload images to Releases
        if: ${{ github.event_name != 'release' && success() }}
        uses: svenstaro/upload-release-action@2.2.0
        with:
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          file: ${{ env.images_dir }}/*.trx
          tag: ${{ github.ref }}
          overwrite: true
          file_glob: true
