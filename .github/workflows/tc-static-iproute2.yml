name: CI with Static TC Build

# 定義觸發條件
on:
  push:
    paths-ignore:
      - '**.md'
  pull_request:
  workflow_dispatch:
    inputs:
      debug_enabled:
        description: 'Run the build with tmate debugging enabled'
        required: false
        default: 'no'
  release:
    types: [published]

jobs:
  build:
    name: build
    runs-on: ubuntu-latest
    if: ${{ !(github.event_name == 'push' && startsWith(github.ref, 'refs/tags/')) }}
    env:
      build_variant: ${{ matrix.build_variant }}
      targets: ${{ matrix.targets }}
      images_dir: /opt/images
    strategy:
      matrix:
        include:
          - build_variant: "mt7621"
            targets: "K2P"
            
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        
      - name: Prepare environment (Install dependencies & Fix C Compiler)
        run: |
          sudo apt update
          # 增加 autoconf/automake 以備 Git 備援方案使用
          sudo apt install -y libtool-bin gperf python3-docutils autopoint gettext bison flex wget xz-utils autoconf automake
          
          # 【修正】確保宿主機 (x86_64) 能運行 MIPS 交叉編譯器所需的 32 位輔助程式
          sudo dpkg --add-architecture i386
          sudo apt update
          # 安裝 32-bit 運行時及開發依賴庫 (已移除 libncurses5:i386)
          sudo apt install -y -qq libc6-i386 lib32z1 lib32stdc++6 lib32ncurses6 lib32z1-dev zlib1g:i386
        shell: bash
        
      # -----------------------------------------------------------
      # 步驟 1: 下載並設定 MIPS 交叉編譯器 (修正 STAGING_DIR/CC 路徑偵測)
      # -----------------------------------------------------------
      - name: ⬇️ 下載並設定 MIPS 交叉編譯器 (OpenWrt SDK)
        id: toolchain_setup
        run: |
          TOOLCHAIN_VERSION="23.05.2"  
          TOOLCHAIN_FILENAME="openwrt-sdk-${TOOLCHAIN_VERSION}-ramips-mt7621_gcc-12.3.0_musl.Linux-x86_64.tar.xz"
          
          # SDK 下載及解壓重試邏輯
          MAX_RETRIES=2
          RETRY_COUNT=0
          SDK_DOWNLOAD_URL="https://downloads.openwrt.org/releases/${TOOLCHAIN_VERSION}/targets/ramips/mt7621/${TOOLCHAIN_FILENAME}"
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              echo "嘗試下載 OpenWrt SDK (第 $((RETRY_COUNT + 1)) 次)..."
              wget "$SDK_DOWNLOAD_URL" -O sdk.tar.xz
              
              echo "解壓工具鏈..."
              mkdir -p sdk
              if tar -Jxf sdk.tar.xz -C sdk --strip-components=1; then
                  echo "SDK 解壓成功。"
                  break
              else
                  RETRY_COUNT=$((RETRY_COUNT + 1))
                  if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
                      echo "::error::錯誤：SDK 下載及解壓在 ${MAX_RETRIES} 次嘗試後仍失敗。"
                      exit 1
                  fi
                  echo "::warning::警告：解壓失敗。清理並重試..."
                  rm -rf sdk sdk.tar.xz  
              fi
          done

          # 尋找 Toolchain 目錄 (包含 bin 和 lib)
          TOOLCHAIN_DIR=$(find sdk/staging_dir -maxdepth 1 -type d -name "toolchain-*" | head -n 1)
          
          if [ -z "$TOOLCHAIN_DIR" ]; then
            echo "::error::錯誤：找不到 Toolchain 目錄。"
            exit 1
          fi

          # 尋找編譯器絕對路徑：在正確的 bin 目錄下尋找 gcc
          TOOLCHAIN_COMPILER_PATH=$(find ${TOOLCHAIN_DIR}/bin -type f -name "*gcc" | head -n 1)
          
          if [ -z "$TOOLCHAIN_COMPILER_PATH" ]; then
            echo "::error::錯誤：找不到編譯器。"
            exit 1
          fi

          TOOLCHAIN_PREFIX=$(basename "$TOOLCHAIN_COMPILER_PATH" | sed 's/gcc$//')
          
          # 尋找 STAGING_DIR
          STAGING_DIR=$(find sdk/staging_dir -maxdepth 1 -type d -name "target-*" | head -n 1)
          
          if [ -z "$STAGING_DIR" ]; then
            echo "::error::錯誤：找不到 Target Staging Directory (在 sdk/staging_dir 內)。"
            exit 1
          fi
          
          echo "偵測到的工具鏈前綴: ${TOOLCHAIN_PREFIX}"
          echo "偵測到的 Staging Dir: ${STAGING_DIR}"

          # 匯出所有環境變數
          echo "CROSS_COMPILE=$TOOLCHAIN_PREFIX" >> $GITHUB_ENV
          echo "CC_FULL_PATH=$TOOLCHAIN_COMPILER_PATH" >> $GITHUB_ENV
          echo "STAGING_DIR=$STAGING_DIR" >> $GITHUB_ENV
          # 優化：將版本號集中在此處定義和匯出
          echo "IPROUTE2_VERSION_LATEST=6.17.0" >> $GITHUB_ENV  
          echo "IPROUTE2_VERSION_FALLBACK=6.8.0" >> $GITHUB_ENV
          echo "TC_STATIC_PATH=${{ github.workspace }}/tc_static_bin" >> $GITHUB_ENV
          
        shell: bash

      # -----------------------------------------------------------
      # 步驟 1.5: 靜態交叉編譯 libmnl (三層下載備援邏輯)
      # -----------------------------------------------------------
      - name: ⚙️ Pre-compile and Install libmnl (三層下載備援)
        run: |
          # 定義所有版本和路徑
          VERSION_TARGET="1.2.7"  
          VERSION_FALLBACK_KNOWN="1.0.5"
          
          URL_TARGET="https://netfilter.org/projects/libmnl/files/libmnl-${VERSION_TARGET}.tar.xz"
          URL_FALLBACK="https://netfilter.org/projects/libmnl/files/libmnl-${VERSION_FALLBACK_KNOWN}.tar.bz2"
          LIBMNL_REPO="https://git.netfilter.org/libmnl.git"
          CLONE_DIR="libmnl-source"
          
          DOWNLOADED_FILE=""
          VERSION_TO_BUILD=""
          BUILD_DIR=""
          # 使用環境變數定義 HOST_TRIPLE
          HOST_TRIPLE=$(echo "${{ env.CROSS_COMPILE }}" | sed 's/-$//')
          
          # 1. 嘗試 WGET (最新版本)
          echo "嘗試 (1/3) WGET 下載最新版本 v${VERSION_TARGET}..."
          if wget -nv "${URL_TARGET}" -O "libmnl-target.tar.xz" 2>/dev/null; then
              DOWNLOADED_FILE="libmnl-target.tar.xz"
              VERSION_TO_BUILD="${VERSION_TARGET}"
          
          # 2. 嘗試 Git Clone (新的備援 1 - 高優先級)
          elif git clone --depth 1 "${LIBMNL_REPO}" "${CLONE_DIR}" 2>/dev/null; then
              echo "✅ WGET 下載失敗。執行 (2/3) Git 倉庫備援下載 (最新 Master HEAD)。"
              VERSION_TO_BUILD="${VERSION_TARGET}-git"
              BUILD_DIR="${CLONE_DIR}"
              
          # 3. 嘗試 WGET (用戶提供版本 - 新的備援 2)
          elif wget -nv "${URL_FALLBACK}" -O "libmnl-fallback.tar.bz2" 2>/dev/null; then
              echo "⚠️ Git 下載失敗。執行 (3/3) 嘗試下載用戶提供的舊版 v${VERSION_FALLBACK_KNOWN}。"
              DOWNLOADED_FILE="libmnl-fallback.tar.bz2"
              VERSION_TO_BUILD="${VERSION_FALLBACK_KNOWN}"
              
          # 4. Final Failure
          else
              echo "::error::錯誤：所有下載嘗試均失敗。"
              exit 1
          fi

          # 準備編譯目錄並進入
          if [ "${VERSION_TO_BUILD}" == "${VERSION_TARGET}-git" ]; then
              # Git 來源 (需要 autogen.sh)
              echo "處理 Git 來源..."
              cd "${BUILD_DIR}"
              echo "運行 autogen.sh 生成 configure 文件..."
              # 確保 autogen.sh 成功
              ./autogen.sh || { echo "::error::autogen.sh 失敗。"; exit 1; }
          else  
              # Tarball 來源 (嘗試 1 或 3)
              echo "處理 Tarball 來源..."
              tar -xf "${DOWNLOADED_FILE}"
              BUILD_DIR="libmnl-${VERSION_TO_BUILD}"
              cd "${BUILD_DIR}"
          fi

          # 執行 configure，使用動態偵測的 CC 絕對路徑
          # 【關鍵修正點】：強制設定 config.cache 及環境變數，解決 C 編譯器測試失敗的問題。
          echo "ac_cv_prog_cc_works=yes" > config.cache

          ac_cv_prog_cc_works=yes ./configure --host=$HOST_TRIPLE \
                              --prefix=/usr \
                              --disable-shared \
                              --enable-static \
                              --cache-file=config.cache \
                              CC="${{ env.CC_FULL_PATH }}" \
                              CFLAGS="-Os -pipe" \
                              LDFLAGS="" || { echo "::error::libmnl configure 失敗。"; exit 1; }
          
          make || { echo "::error::libmnl make 失敗。"; exit 1; }
          # 將靜態函式庫和標頭檔安裝到 SDK 的目標目錄 (使用動態偵測的 STAGING_DIR)
          make install DESTDIR="${{ env.STAGING_DIR }}" || { echo "::error::libmnl install 失敗。"; exit 1; }
          
          echo "libmnl v${VERSION_TO_BUILD} 靜態編譯完成並安裝到 ${{ env.STAGING_DIR }}/usr/lib"
          cd ..
        shell: bash

      # -----------------------------------------------------------
      # 步驟 2: 靜態編譯 TC (使用 CC 絕對路徑及 libmnl 連結旗標)
      # -----------------------------------------------------------
      - name: Download and Statically Compile TC
        run: |
          LATEST_VERSION="${{ env.IPROUTE2_VERSION_LATEST }}"
          FALLBACK_VERSION="${{ env.IPROUTE2_VERSION_FALLBACK }}"
          VERSION_TO_USE=""
          ARCHIVE_SUFFIX=""
          BASE_URL="https://www.kernel.org/pub/linux/utils/net/iproute2/"
          # 構造 AR 路徑
          AR_FULL_PATH=$(echo "${{ env.CC_FULL_PATH }}" | sed 's/gcc$/ar/')

          # 函數：嘗試下載並設定版本
          try_download() {
              local version=$1
              if wget -nv "${BASE_URL}iproute2-${version}.tar.xz"; then
                  VERSION_TO_USE="${version}"; ARCHIVE_SUFFIX=".tar.xz"; echo "已找到版本 ${version} (${ARCHIVE_SUFFIX}) - 優先使用。"; return 0
              fi
              if wget -nv "${BASE_URL}iproute2-${version}.tar.gz"; then
                  VERSION_TO_USE="${version}"; ARCHIVE_SUFFIX=".tar.gz"; echo "已找到版本 ${version} (${ARCHIVE_SUFFIX})。" ; return 0
              fi
              return 1
          }

          # 執行下載
          echo "嘗試下載最新版本 iproute2-${LATEST_VERSION}..."
          if ! try_download "${LATEST_VERSION}"; then
              echo "::warning::警告：最新版本 ${LATEST_VERSION} 無法下載。嘗試回退到 ${FALLBACK_VERSION} 版本。"
              if ! try_download "${FALLBACK_VERSION}"; then
                  echo "::error::錯誤：iproute2 下載失敗。" ; exit 1
              fi
          fi

          # 解壓
          tar -xf iproute2-${VERSION_TO_USE}${ARCHIVE_SUFFIX}
          cd iproute2-${VERSION_TO_USE}

          # 靜態交叉編譯 tc：
          make CC="${{ env.CC_FULL_PATH }}" \
               LDFLAGS="-static -L${{ env.STAGING_DIR }}/usr/lib -lmnl" \
               CFLAGS="-I${{ env.STAGING_DIR }}/usr/include" \
               AR="${AR_FULL_PATH}" \
               SUBDIRS=tc || { echo "::error::tc make 失敗。"; exit 1; }
          
          mkdir -p ${{ env.TC_STATIC_PATH }}
          # 檢查 tc 執行檔是否成功生成
          if [ ! -f "tc/tc" ]; then
            echo "::error::錯誤：tc/tc 執行檔未成功生成，靜態編譯失敗。"
            exit 1
          fi
          
          cp tc/tc ${{ env.TC_STATIC_PATH }}/tc_static_mipsel
          
          echo "--- 靜態連結驗證結果 ---"
          file ${{ env.TC_STATIC_PATH }}/tc_static_mipsel
          
          echo "IPROUTE2_VERSION=${VERSION_TO_USE}" >> $GITHUB_ENV

        shell: bash

      # -----------------------------------------------------------
      # 步驟 3: 上傳靜態 TC Binary 作為 Artifact
      # -----------------------------------------------------------
      - name: Upload Static TC Binary as Artifact
        uses: actions/upload-artifact@v4
        with:
          name: tc_static_mipsel_${{ env.IPROUTE2_VERSION }}  
          path: ${{ env.TC_STATIC_PATH }}/tc_static_mipsel
          retention-days: 90
          
      # -----------------------------------------------------------
      # 後續韌體編譯流程
      # -----------------------------------------------------------
      - name: Setup tmate session
        uses: mxschmitt/action-tmate@v3
        if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.debug_enabled == 'yes' }}
        with:
          limit-access-to-actor: true
          
      - name: Start build
        run: |
          cd trunk
          mkdir -p ${images_dir}
          for m in $targets; do  
            fakeroot ./build_firmware_ci $m
            if [ $? -eq 0 ]; then  
              cp -f images/*.trx ${images_dir}/$m.trx
            else  
              echo "::error::韌體編譯失敗: $m"
              exit 1
            fi
            ./clear_tree_simple >/dev/null 2>&1
          done
          
      - name: Create archive
        if: ${{ github.event_name != 'release' && success() }}
        run: |
          ls -lh ${images_dir}
          GIT_VERSION=`git rev-parse --short=7 HEAD 2>/dev/null` && [ -n "$GIT_VERSION" ] && \
          image_name=images_${build_variant}_${GIT_VERSION} || image_name=images_${build_variant}
          cd ${images_dir}; md5sum *.trx |tee md5sum.txt; 7z a -mx=9 ${image_name}.7z ./*
          echo "image_name=${image_name}" >> $GITHUB_ENV
          
      - name: Upload images to Artifact
        if: ${{ github.event_name != 'release' && success() }}
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.image_name }}
          path: ${{ env.images_dir }}/*.7z
          
      - name: Upload images to Releases
        if: ${{ github.event_name != 'release' && success() }}
        uses: svenstaro/upload-release-action@2.2.0
        with:
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          file: ${{ env.images_dir }}/*.trx
          tag: ${{ github.ref }}
          overwrite: true
          file_glob: true
